generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Branch {
  id                   String             @id @default(cuid())
  name                 String
  address              String?
  code                 String             @unique
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  imageUrl             String?
  phone                String?
  ticketPrefix         String             @default("MAC")
  cashShifts           CashShift[]
  customers            Customer[]
  expenses             Expense[]
  productStocks        ProductStock[]
  repairs              Repair[]
  sales                Sale[]
  sparePartHistory     SparePartHistory[]
  stockTransfersSource StockTransfer[]    @relation("SourceBranch")
  stockTransfersTarget StockTransfer[]    @relation("TargetBranch")
  tickets              Ticket[]
  users                User[]

  @@map("branches")
}

model User {
  id                    String                @id @default(cuid())
  email                 String                @unique
  password              String
  name                  String
  role                  Role                  @default(VENDOR)
  branchId              String?
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  isOnline              Boolean               @default(false)
  lastActiveAt          DateTime?
  imageUrl              String?
  avgDataQuality        Float                 @default(0)
  cashShifts            CashShift[]
  cerebroConversations  CerebroConversation[]
  customersCreated      Customer[]
  expenses              Expense[]
  notifications         Notification[]
  repairKnowledge       RepairKnowledge[]
  observations          RepairObservation[]
  repairsAssigned       Repair[]              @relation("AssignedRepairs")
  repairsCreated        Repair[]              @relation("CreatedRepairs")
  resolvedReturns       ReturnRequest[]       @relation("AdminResolvedReturns")
  technicianReturns     ReturnRequest[]       @relation("TechnicianReturns")
  sales                 Sale[]
  sparePartHistory      SparePartHistory[]
  stockTransfersCreated StockTransfer[]
  branch                Branch?               @relation(fields: [branchId], references: [id], onDelete: Cascade)

  @@index([email])
  @@index([branchId])
  @@map("users")
}

model Category {
  id          String       @id @default(cuid())
  name        String
  type        CategoryType @default(PRODUCT)
  description String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  products    Product[]
  spareParts  SparePart[]

  @@map("categories")
}

model Product {
  id             String          @id @default(cuid())
  name           String
  sku            String          @unique
  price          Float
  description    String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  categoryId     String?
  costPrice      Float           @default(0)
  deletedAt      DateTime?
  profitMargin   Float           @default(0)
  stock          ProductStock[]
  category       Category?       @relation(fields: [categoryId], references: [id])
  saleItems      SaleItem[]
  stockTransfers StockTransfer[]

  @@index([sku])
  @@index([categoryId])
  @@map("products")
}

model ProductStock {
  id            String    @id @default(cuid())
  productId     String
  branchId      String
  quantity      Int       @default(0)
  updatedAt     DateTime  @updatedAt
  lastCheckedAt DateTime?
  branch        Branch    @relation(fields: [branchId], references: [id], onDelete: Cascade)
  product       Product   @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([productId, branchId])
  @@index([branchId])
  @@map("product_stocks")
}

model StockTransfer {
  id             String         @id @default(cuid())
  productId      String
  sourceBranchId String
  targetBranchId String
  quantity       Int
  status         TransferStatus @default(PENDING)
  createdById    String
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  notes          String?
  createdBy      User           @relation(fields: [createdById], references: [id])
  product        Product        @relation(fields: [productId], references: [id])
  sourceBranch   Branch         @relation("SourceBranch", fields: [sourceBranchId], references: [id])
  targetBranch   Branch         @relation("TargetBranch", fields: [targetBranchId], references: [id])

  @@index([sourceBranchId])
  @@index([targetBranchId])
  @@index([productId])
  @@map("stock_transfers")
}

model Ticket {
  id           String   @id @default(cuid())
  ticketNumber String   @unique
  customerName String
  device       String
  issue        String
  status       String   @default("pending")
  branchId     String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  branch       Branch   @relation(fields: [branchId], references: [id], onDelete: Cascade)

  @@index([branchId])
  @@index([ticketNumber])
  @@map("tickets")
}

model Sale {
  id                    String         @id @default(cuid())
  saleNumber            String         @unique
  total                 Float
  vendorId              String
  branchId              String
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
  paymentMethod         PaymentMethod  @default(CASH)
  originalPaymentMethod PaymentMethod?
  wasPaymentModified    Boolean        @default(false)
  invoice               SaleInvoice?
  items                 SaleItem[]
  payments              SalePayment[]
  branch                Branch         @relation(fields: [branchId], references: [id], onDelete: Cascade)
  vendor                User           @relation(fields: [vendorId], references: [id], onDelete: Cascade)

  @@index([branchId])
  @@index([vendorId])
  @@index([saleNumber])
  @@map("sales")
}

model SaleInvoice {
  id              String   @id @default(cuid())
  saleId          String   @unique
  invoiceType     String
  invoiceNumber   String
  cae             String
  caeExpiresAt    DateTime
  customerDocType String
  customerDoc     String
  customerName    String
  customerAddress String?
  netAmount       Float
  vatAmount       Float
  totalAmount     Float
  createdAt       DateTime @default(now())
  billingEntity   String?
  sale            Sale     @relation(fields: [saleId], references: [id], onDelete: Cascade)

  @@map("sale_invoices")
}

model SaleItem {
  id                String   @id @default(cuid())
  saleId            String
  name              String
  quantity          Int
  price             Float
  productId         String?
  repairId          String?
  originalPrice     Float?
  priceChangeReason String?
  product           Product? @relation(fields: [productId], references: [id])
  repair            Repair?  @relation(fields: [repairId], references: [id])
  sale              Sale     @relation(fields: [saleId], references: [id], onDelete: Cascade)

  @@index([saleId])
  @@index([productId])
  @@index([repairId])
  @@map("sale_items")
}

model SalePayment {
  id        String        @id @default(cuid())
  saleId    String
  amount    Float
  method    PaymentMethod
  createdAt DateTime      @default(now())
  sale      Sale          @relation(fields: [saleId], references: [id], onDelete: Cascade)

  @@index([saleId])
  @@map("sale_payments")
}

model SparePart {
  id            String             @id @default(cuid())
  name          String
  sku           String             @unique
  brand         String
  categoryId    String?
  stockLocal    Int                @default(0)
  stockDepot    Int                @default(0)
  maxStockLocal Int                @default(0)
  priceUsd      Float              @default(0)
  priceArg      Float              @default(0)
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  deletedAt     DateTime?
  pricePos      Float              @default(0)
  repairParts   RepairPart[]
  history       SparePartHistory[]
  category      Category?          @relation(fields: [categoryId], references: [id])

  @@index([sku])
  @@index([categoryId])
  @@map("spare_parts")
}

model Customer {
  id              String    @id @default(cuid())
  name            String
  phone           String
  email           String?
  branchId        String
  userId          String
  isFinalConsumer Boolean   @default(false)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  deletedAt       DateTime?
  branch          Branch    @relation(fields: [branchId], references: [id])
  createdBy       User      @relation(fields: [userId], references: [id])
  repairs         Repair[]

  @@unique([phone, branchId])
  @@index([phone])
  @@index([name])
  @@map("customers")
}

model RepairStatus {
  id        Int      @id @default(autoincrement())
  name      String
  color     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  repairs   Repair[]

  @@map("repair_statuses")
}

model Repair {
  id                 String              @id @default(cuid())
  ticketNumber       String              @unique
  branchId           String
  customerId         String
  userId             String
  assignedUserId     String?
  statusId           Int                 @default(1)
  deviceBrand        String
  deviceModel        String
  problemDescription String
  deviceImages       String[]
  estimatedPrice     Float?
  promisedAt         DateTime
  isWarranty         Boolean             @default(false)
  originalRepairId   String?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  diagnosis          String?
  estimatedTime      Int?
  finishedAt         DateTime?
  startedAt          DateTime?
  isWet              Boolean             @default(false)
  dataQualityScore   Int                 @default(0)
  diagnosisEnriched  String?
  diagnosticJson     Json?
  observations       RepairObservation[]
  parts              RepairPart[]
  assignedTo         User?               @relation("AssignedRepairs", fields: [assignedUserId], references: [id])
  branch             Branch              @relation(fields: [branchId], references: [id])
  customer           Customer            @relation(fields: [customerId], references: [id])
  originalRepair     Repair?             @relation("WarrantyRelation", fields: [originalRepairId], references: [id])
  warrantyRepairs    Repair[]            @relation("WarrantyRelation")
  status             RepairStatus        @relation(fields: [statusId], references: [id])
  createdBy          User                @relation("CreatedRepairs", fields: [userId], references: [id])
  returnRequests     ReturnRequest[]
  saleItems          SaleItem[]

  @@unique([ticketNumber, branchId])
  @@index([branchId])
  @@index([customerId])
  @@index([statusId])
  @@map("repairs")
}

model RepairObservation {
  id        String   @id @default(cuid())
  repairId  String
  userId    String?
  content   String
  createdAt DateTime @default(now())
  repair    Repair   @relation(fields: [repairId], references: [id], onDelete: Cascade)
  user      User?    @relation(fields: [userId], references: [id])

  @@index([repairId])
  @@map("repair_observations")
}

model RepairPart {
  id          String    @id @default(cuid())
  repairId    String
  sparePartId String
  quantity    Int       @default(1)
  assignedAt  DateTime  @default(now())
  repair      Repair    @relation(fields: [repairId], references: [id], onDelete: Cascade)
  sparePart   SparePart @relation(fields: [sparePartId], references: [id])

  @@map("repair_parts")
}

model Notification {
  id         String   @id @default(cuid())
  userId     String
  title      String
  message    String
  isRead     Boolean  @default(false)
  type       String   @default("INFO")
  actionData Json?
  status     String?
  link       String?
  createdAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("notifications")
}

model CashShift {
  id            String    @id @default(cuid())
  branchId      String
  userId        String
  startTime     DateTime  @default(now())
  endTime       DateTime?
  startAmount   Float     @default(0)
  endAmount     Float?
  status        String    @default("OPEN")
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  bonusTotal    Float     @default(0)
  employeeCount Int       @default(1)
  branch        Branch    @relation(fields: [branchId], references: [id], onDelete: Cascade)
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([branchId])
  @@index([userId])
  @@index([status])
  @@map("cash_shifts")
}

model Expense {
  id          String   @id @default(cuid())
  branchId    String
  userId      String
  amount      Float
  description String
  createdAt   DateTime @default(now())
  branch      Branch   @relation(fields: [branchId], references: [id])
  user        User     @relation(fields: [userId], references: [id])

  @@index([branchId])
  @@index([userId])
  @@map("expenses")
}

model ReturnRequest {
  id             String       @id @default(cuid())
  repairId       String
  technicianId   String
  status         ReturnStatus @default(PENDING)
  technicianNote String?
  adminNote      String?
  resolutionDate DateTime?
  resolvedBy     String?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  partsSnapshot  Json?
  repair         Repair       @relation(fields: [repairId], references: [id], onDelete: Cascade)
  resolvedByUser User?        @relation("AdminResolvedReturns", fields: [resolvedBy], references: [id])
  technician     User         @relation("TechnicianReturns", fields: [technicianId], references: [id])

  @@index([repairId])
  @@index([technicianId])
  @@index([status])
  @@map("return_requests")
}

model backups {
  id        String   @id
  name      String   @unique
  size      Int
  content   Bytes
  createdAt DateTime @default(now())
}

/// Familias de dispositivos con checklists dinámicos para el diagnóstico estructurado
model DeviceFamily {
  id            String   @id @default(cuid())
  name          String
  checklistJson Json
  createdAt     DateTime @default(now())

  @@map("device_families")
}

/// Soluciones y conocimiento técnico registrado por el equipo de MACCELL
model RepairKnowledge {
  id          String   @id @default(cuid())
  deviceBrand String
  deviceModel String
  problemTags String[]
  title       String
  content     String
  mediaUrls   String[]
  authorId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  author      User     @relation(fields: [authorId], references: [id])

  @@index([deviceBrand, deviceModel])
  @@map("repair_knowledge")
}

/// Embeddings vectoriales de reparaciones para búsqueda semántica RAG
/// Requiere extensión pgvector: CREATE EXTENSION IF NOT EXISTS vector;
model RepairEmbedding {
  id          String   @id @default(cuid())
  repairId    String   @unique
  ticketNumber String
  deviceBrand String
  deviceModel String
  /// Campo vectorial — manejado manualmente con SQL raw (pgvector no soportado por Prisma natively)
  contentText String   // Texto indexado: problema + diagnóstico
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([deviceBrand, deviceModel])
  @@map("repair_embeddings")
}

/// Conversaciones del chat de Cerebro (una por sesión de trabajo)
model CerebroConversation {
  id        String           @id @default(cuid())
  userId    String
  title     String?
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages  CerebroMessage[]

  @@index([userId])
  @@map("cerebro_conversations")
}

/// Mensajes individuales dentro de una conversación de Cerebro
model CerebroMessage {
  id             String              @id @default(cuid())
  conversationId String
  role           String
  content        String
  mediaUrls      String[]
  createdAt      DateTime            @default(now())
  conversation   CerebroConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@map("cerebro_messages")
}

model SparePartHistory {
  id          String    @id @default(cuid())
  sparePartId String
  userId      String
  branchId    String
  quantity    Int
  reason      String?
  isChecked   Boolean   @default(false)
  createdAt   DateTime  @default(now())
  branch      Branch    @relation(fields: [branchId], references: [id], onDelete: Cascade)
  sparePart   SparePart @relation(fields: [sparePartId], references: [id], onDelete: Cascade)
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([sparePartId])
  @@index([userId])
  @@index([branchId])
  @@map("spare_part_history")
}

enum Role {
  ADMIN
  VENDOR
  TECHNICIAN
}

enum PaymentMethod {
  CASH
  CARD
  MERCADOPAGO
  SPLIT
}

enum CategoryType {
  PRODUCT
  PART
}

enum TransferStatus {
  PENDING
  COMPLETED
  CANCELLED
}

enum ReturnStatus {
  PENDING
  ACCEPTED
  REJECTED
}
